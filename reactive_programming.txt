Reactive Programming
=====================
Reactive programming is a programming style where we define a source and a consumer of data. Once we connect the consumer to the source, the library takes care of pushing the data, generated by the source, to the consumer.
RxJava library helps programmers to write asynchronous, concurrent, and resilient applications.
RxJava is not a native java8 feature, but it is a library which uses java8 features extensively and a good to know feature.


Reactive Vs Imperative Programming
===================================
Let's learn this with a simple example.
Imperative programming
-----------------------
x = y + z
Here, the sum of y and z will be assigned to variable x. Suppose at later point, values of y or z change, this will not automatically influence the value of x.
Reactive programming
---------------------
Value of x is updated whenever the values of y or z change.


Pull Vs Push
=============
In functional programming, iterators are used to pull and process data synchronously.
In functional reactive programming, we push the same stream of data that we used to have in a collection asynchronously into an observer.


Reactive Programming
=====================
Reactive Programming deals with the below.
Source of data
Consumer of data


What's ReactiveX?
==================
ReactiveX is a collection of the best ideas from the Observer pattern, the Iterator pattern, and functional programming.
A library that implements functional reactive programming in various languages.
Uses "observables" to represent asynchronous data streams


What's RxJava?
===============
Library that implements the concepts of ReactiveX in Java.
RxJava library provides a model to work with events generated from UI or asynchronous calls in the same way as collections and streams in Java 8.


RxJava
Quick Example:
===============
// defining the source
Observable<Integer> source = Observable.range(1, 5);
// defining the consumer
Subscriber<Integer> consumer = new Subscriber<Integer>() {
    @Override
    public void onNext(Integer number) { System.out.println(number); }
    @Override
    public void onError(Throwable e) { System.out.println("error"); }
    @Override
    public void onCompleted() { System.out.println("completed"); }
};
// connecting the consumer to source
source.subscribe(consumer);

Example (contd 1...)
=====================
###Source of Data (Observable)
Observable<T> represents a source. An Observable can be created using one of the many factory methods it provides. Observable.range(int start, int count) is one of them.
###Consumer of Data (Observer)
Subscriber<T> serves as a consumer of data. RxJava uses onNext(T data) method on the Subscriber to push the data emitted by the source, the Observable, to the consumer of data, the Subscriber.

Example (contd 2...)
=====================
Once all the data is emitted by the source, RxJava signals the completion using onComplete() method on the Subscriber.
If there is any error observed during emission of data, RxJava forwards the error to onError(Throwable e) method on the Subscriber.
###Connecting Consumer to Source
This is established using the subscribe(consumer) method on Observable.
In RxJava, the computations as a part of Observable and Subscriber get executed only when the connection is established.


Java 8 Example- Concise version
================================
Observable.range(1, 5).subscribe(
    number -> System.out.println(number),
    error -> System.out.println("error"),
    () -> System.out.println("completed")
);